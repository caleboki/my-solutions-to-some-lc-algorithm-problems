{"id":740214289,"lang":"javascript","lang_name":"JavaScript","time":"11 months, 3 weeks","timestamp":1657126590,"status":10,"status_display":"Accepted","runtime":"732 ms","url":"/submissions/detail/740214289/","is_pending":"Not Pending","title":"Shortest Path in a Grid with Obstacles Elimination","memory":"89.1 MB","code":"/**\n * @param {number[][]} grid\n * @param {number} k\n * @return {number}\n */\n// var shortestPath = function(grid, k) {\n//     let directions = [[0, -1], [0, 1], [-1, 0], [1, 0]]\n//     const getNeigbours = (directions, row, col, grid) => {\n//         let neigbours = []\n//         for (let d of directions) {\n//             let nRow = row + d[0]\n//             let nCol = col + d[1]\n            \n//             if (nRow < 0 || nCol < 0 || nRow >= grid.length || nCol >= grid[0].length) {\n//                 continue\n//             }\n//             if (grid[nRow][nCol] !== 0) {\n//                 if (k === 0) continue\n//                 k--\n//             }\n//             neigbours.push([nRow, nCol])\n//         }\n//         return neigbours\n//     }\n    \n//     const bfs = (grid) => {\n//         let queue = [[0, 0, 0]], visited = new Set('00')\n//         while (queue.length) {\n//             let cell = queue.shift()\n//             let [row, col, distance, k] = cell\n//             if (row === grid.length - 1 && col === grid[0].length - 1) return distance\n//             for (let neigbour of getNeigbours(directions, row, col, grid)) {\n//                 let [nRow, nCol] = neigbour\n//                 let current = nRow.toString() + nCol.toString()\n//                 if (visited.has(current)) continue\n//                 visited.add(current)\n//                 queue.push([nRow, nCol, distance + 1])\n//             }\n//         }\n//         return -1\n//     }\n//     return bfs(grid)\n// };\n\nvar shortestPath = function(grid, k) {\n    /**\n        Concept:\n        -- Since we are given a grid of cells and we have to find the shortest path between two cells,\n           we can solve this problem using BFS.\n        -- The grid may contain many obstacles and there are K obstacles that can be eliminated.\n        -- Once we have eliminated K obstacles, there's no path and an alternate path must be considered\n        -- Therefore, we must know at each cell we are visiting what value of K we brought to that cell\n        -- Also, to avoid getting stuck in a loop of wrong path, we must avoid paths already visited\n        \n        Approach:\n        -- Push a tuple [ row, col, remainingK ] into a queue. Also put combination as seen in a set.\n        -- For each tuple that we remove from the queue:\n           -- Check if row and col are lower right coordinates. If true, return moves taken so far.\n           -- If not true,\n              -- Move in each of the four directions from that cell to find its neighbor\n              -- Validate the neighbor:\n                 -- Check for out of bounds\n                 -- Check if neighbor cell has an obstacle and if K is exhausted\n              -- If validated, do the following if neighbor is not seen before:\n                 -- If not obstacle, add neighbor coordinates and remaining K to queue and set.\n                 -- If obstacle, decrement remaining k and add values to queue and set.\n    */\n    \n    // Time Complexity: O(m*n) --> Worst case traversing all cells\n    // Space Complexity: O(m*n) --> Worst case storing all cells\n    \n    if (!grid || grid.length === 0) return 0;\n    \n    const rows = grid.length, cols = grid[0].length, directions = [[-1, 0], [1, 0], [0, -1], [0, 1]], visited = new Set()\n    \n    visited.add(`0-0-${k}`);\n    \n    let moves = 0, queue = [[0, 0, k]];// Starting coordinates and k\n    \n    while (queue.length > 0) {\n        let nextMoves = [];\n        \n        while (queue.length > 0) {\n            let [x, y, remainingK] = queue.shift();\n            \n            if (x === rows - 1 && y === cols - 1) return moves;// Reached destination => return moves\n            \n            for (const direction of directions) {\n                let row = x + direction[0], col = y + direction[1];\n                \n                // Check for out of bounds or too many obstacles to eliminate\n                if (row < 0 || col < 0 || row >= rows || col >= cols ||\n                   (grid[row][col] === 1 && remainingK === 0)) continue;\n                \n                // Consider a decremented k while discovering next 4 neighbors if obstacle\n                let newK = grid[row][col] === 1 ? remainingK - 1 : remainingK;\n                let key = `${row}-${col}-${newK}`;\n                \n                if (!visited.has(key)) {\n                    visited.add(key);\n                    nextMoves.push([row, col, newK]);\n                }\n            }\n        }\n        \n        queue = nextMoves;\n        moves++;\n    }\n    \n    return -1;// return -1 if no path found\n};","compare_result":"1111111111111111111111111111111111111111111111111111","title_slug":"shortest-path-in-a-grid-with-obstacles-elimination","has_notes":false}