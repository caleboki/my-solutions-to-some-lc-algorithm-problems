{"id":739574579,"lang":"javascript","lang_name":"JavaScript","time":"11 months, 3 weeks","timestamp":1657067199,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/739574579/","is_pending":"Not Pending","title":"Shortest Path in a Grid with Obstacles Elimination","memory":"N/A","code":"/**\n * @param {number[][]} grid\n * @param {number} k\n * @return {number}\n */\n// var shortestPath = function(grid, k) {\n//     let directions = [[0, -1], [0, 1], [-1, 0], [1, 0]]\n//     const getNeigbours = (directions, row, col, grid) => {\n//         let neigbours = []\n//         for (let d of directions) {\n//             let nRow = row + d[0]\n//             let nCol = col + d[1]\n            \n//             if (nRow < 0 || nCol < 0 || nRow >= grid.length || nCol >= grid[0].length) {\n//                 continue\n//             }\n//             if (grid[nRow][nCol] !== 0) {\n//                 if (k === 0) continue\n//                 k--\n//             }\n//             neigbours.push([nRow, nCol])\n//         }\n//         return neigbours\n//     }\n    \n//     const bfs = (grid) => {\n//         let queue = [[0, 0, 0]], visited = new Set('00')\n//         while (queue.length) {\n//             let cell = queue.shift()\n//             let [row, col, distance, k] = cell\n//             if (row === grid.length - 1 && col === grid[0].length - 1) return distance\n//             for (let neigbour of getNeigbours(directions, row, col, grid)) {\n//                 let [nRow, nCol] = neigbour\n//                 let current = nRow.toString() + nCol.toString()\n//                 if (visited.has(current)) continue\n//                 visited.add(current)\n//                 queue.push([nRow, nCol, distance + 1])\n//             }\n//         }\n//         return -1\n//     }\n//     return bfs(grid)\n// };\n\nconst shortestPath = (grid, k) => {\n    let directions = [[1, 0], [-1, 0], [0, -1], [0, 1]]\n    \n    const getNeigbours = (directions, row, col, grid) => {\n        let neigbours = []\n        \n        for (let d of directions) {\n            let nRow = d[0] + row\n            let nCol = d[1] + col\n            \n            if (nRow < 0 || nCol < 0 || nRow >= grid.length || nCol >= grid[0].length) continue\n        }\n        \n        return neigbours\n    }\n    \n    const bfs = (grid, k) => {\n        \n        if (k >= (grid.length - 1) + (grid[0].length - 1)) return (grid.length + grid[0].length) - 2\n        \n        let queue = [[0, 0, 0, k]], visited = new Map()\n        visited.set(`00${k}`, true)\n        \n        while (queue.length) {\n            let [row, col, distance, left] = queue.shift()\n            \n            if (row === grid.length - 1 && col === grid[0].length - 1) return distance\n            \n            for (let d of directions) {\n                let nRow = d[0] + row\n                let nCol = d[1] + col\n                \n                if ((0 <= nRow && nRow < grid.length) && (0 <= nCol && nCol < grid[0].length)) {\n                    let newLeft = left - grid[nRow][nCol]\n                    let newState = [nRow, nCol, newLeft]\n                    \n                    if (newLeft >= 0 && !visited.has(newState.join(''))) visited.set(newState.join(''), true)\n                    \n                    queue.push([nRow, nCol, distance + 1, newLeft])\n                }\n                \n            }\n             \n        } \n        \n        return -1\n    }\n    \n    return bfs(grid, k)\n}","compare_result":"1011111111111111111110000000000000000000000000000000","title_slug":"shortest-path-in-a-grid-with-obstacles-elimination","has_notes":false}