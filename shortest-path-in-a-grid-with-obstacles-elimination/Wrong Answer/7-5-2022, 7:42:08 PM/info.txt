{"id":739553275,"lang":"javascript","lang_name":"JavaScript","time":"11 months, 3 weeks","timestamp":1657064528,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/739553275/","is_pending":"Not Pending","title":"Shortest Path in a Grid with Obstacles Elimination","memory":"N/A","code":"/**\n * @param {number[][]} grid\n * @param {number} k\n * @return {number}\n */\n// var shortestPath = function(grid, k) {\n//     let directions = [[0, -1], [0, 1], [-1, 0], [1, 0]]\n//     const getNeigbours = (directions, row, col, grid) => {\n//         let neigbours = []\n//         for (let d of directions) {\n//             let nRow = row + d[0]\n//             let nCol = col + d[1]\n            \n//             if (nRow < 0 || nCol < 0 || nRow >= grid.length || nCol >= grid[0].length) {\n//                 continue\n//             }\n//             if (grid[nRow][nCol] !== 0) {\n//                 if (k === 0) continue\n//                 k--\n//             }\n//             neigbours.push([nRow, nCol])\n//         }\n//         return neigbours\n//     }\n    \n//     const bfs = (grid) => {\n//         let queue = [[0, 0, 0]], visited = new Set('00')\n//         while (queue.length) {\n//             let cell = queue.shift()\n//             let [row, col, distance, k] = cell\n//             if (row === grid.length - 1 && col === grid[0].length - 1) return distance\n//             for (let neigbour of getNeigbours(directions, row, col, grid)) {\n//                 let [nRow, nCol] = neigbour\n//                 let current = nRow.toString() + nCol.toString()\n//                 if (visited.has(current)) continue\n//                 visited.add(current)\n//                 queue.push([nRow, nCol, distance + 1])\n//             }\n//         }\n//         return -1\n//     }\n//     return bfs(grid)\n// };\n\n// const shortestPath = (grid, k) => {\n//     let directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n    \n//     const getNeigbours = (directions, row, col, grid) => {\n//         let neigbours = []\n        \n//         for (let d of directions) {\n//             let nRow = d[0] + row\n//             let nCol = d[1] + col\n            \n//             if (nRow < 0 || nCol < 0 || nRow >= grid.length || nCol >= grid[0].length) continue\n//         }\n        \n//         return neigbours\n//     }\n    \n//     const bfs = (grid, k) => {\n//         let queue = [[0, 0, 0, k]], visited = new Map()\n        \n//         while (queue.length) {\n//             let [row, col, distance, left] = queue.shift()\n            \n//             if (row === grid.length - 1 && col === grid[0].length - 1) return distance\n//             if (visited.has(`${row}${col}${left}`) || left < 0) continue\n            \n//             visited.set(`${row}${col}${left}`, true)\n            \n//             if (grid[row][col] === 1) left--\n            \n//             for (let neigbour of getNeigbours(directions, row, col, grid)) {\n//                 let [nRow, nCol] = neigbour\n//                 queue.push([nRow, nCol, distance + 1, left]) \n//             }\n//         }\n        \n//         return -1\n//     }\n    \n//     return bfs(grid, k)\n// }\n\nvar shortestPath = function(grid, k) {\n      const queue = [ [0, 0, 0] ];\n      const visited = new Set([ 0 + ',' + 0 ]);\n     const rows = grid.length, cols = grid[0].length;\n    \n      while (queue.length > 0) {\n        const [ row, col, distance ] = queue.shift();\n    \n        if (row === rows - 1 && col === cols - 1) return distance;\n\n        const deltas = [[1, 0], [-1, 0], [0, 1], [0, -1]];\n        for (let delta of deltas)  {\n          const [deltaRow, deltaCol] = delta;\n          const neighborRow = row + deltaRow;\n          const neighborCol = col + deltaCol;\n          const neighborPos = neighborRow + ',' + neighborCol;\n          const rowInbounds = 0 <= neighborRow && neighborRow < grid.length;\n          const colInbounds = 0 <= neighborCol && neighborCol < grid[0].length;\n          if (rowInbounds && colInbounds && !visited.has(neighborPos) && grid[neighborRow][neighborCol] !== 'X') {\n            visited.add(neighborPos);\n            queue.push([ neighborRow, neighborCol, distance + 1 ]);\n          }\n        }\n      }\n\n      return -1;\n};","compare_result":"1011111111111111111110101011111111011111111111111011","title_slug":"shortest-path-in-a-grid-with-obstacles-elimination","has_notes":false}