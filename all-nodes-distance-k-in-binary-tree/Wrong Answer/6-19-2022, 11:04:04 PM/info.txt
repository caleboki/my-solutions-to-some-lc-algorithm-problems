{"id":726393968,"lang":"javascript","lang_name":"JavaScript","time":"1Â year","timestamp":1655694244,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/726393968/","is_pending":"Not Pending","title":"All Nodes Distance K in Binary Tree","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} target\n * @param {number} k\n * @return {number[]}\n */\n// var distanceK = function(root, target, k) {\n    \n//     if (!root || !target) return []\n//     if (k === 0) return [target.val]\n    \n//     //turn the tree into into a graph\n    \n//     //do bfs on the graph\n    \n//     const treeToGraph = (root) => {\n//         let adjList = {}\n//         let queue = [root]\n//         //queue.push(root)\n        \n//         while (queue.length) {\n//             let current = queue.shift()\n            \n//             if (!(current in adjList)) {\n//                 adjList[current] = []\n//             }\n//             //add child to parent adjlist\n//             //add parent to child adjlist\n//             //add child to queue\n            \n//             if (current.left) {\n//                 adjList[current].push(current.left)\n                \n//                 if (!(current.left in adjList)) adjList[current.left] = []\n//                 adjList[current.left].push(current)\n                \n//                 queue.push(current.left)\n//             }\n            \n//             if (current.right) {\n//                 adjList[current].push(current.right)\n                \n//                 if (!(current.right in adjList)) adjList[current.right] = []\n//                 adjList[current.right].push(current)\n                \n//                 queue.push(current.right)\n//             }\n//         }\n        \n//         return adjList\n//     }\n    \n//     const adjList = treeToGraph(root)\n    \n//     let result = [], depth = 0, visited = new Set()\n//     let queue = [target] //start from target node\n    \n//     while (queue.length && depth <= k) {\n//         for (let i = 0; i < queue.length; i++) {\n//             let current = queue.shift()\n            \n//             if (!(current in visited)) {\n//                 for (let child of adjList[current]) {\n//                     queue.push(child)\n//                 }\n            \n//             if (depth === k) result.push(current.val)\n//             visited.add(current)\n//         }\n//         depth++\n//         }\n//     }\n    \n//     return result\n// };\n\nconst distanceK = (root, target, k) => {\n    let adjList = {}, res = [], depth = 0, visited = new Set(), queue = [target.val]\n    \n    const treeToGraph = (node) => {\n        if (!node) return adjList\n        \n        const queue = [node]\n        \n        while (queue.length) {\n            const length = queue.length\n            \n            for (let i = 0; i < length; i++) {\n                const current = queue.shift()\n                \n                if (!(current.val in adjList)) adjList[current.val] = []\n                if (current.left) {\n                    adjList[current.val].push(current.left.val)\n                    adjList[current.left.val] = []\n                    adjList[current.left.val].push(current.val)\n                    queue.push(current.left)\n                }\n                if (current.right) {\n                    adjList[current.val].push(current.right.val)\n                    adjList[current.right.val] = []\n                    adjList[current.right.val].push(current.val)\n                    queue.push(current.right)\n                }\n            }\n        }\n        \n        \n        return adjList\n    }\n    \n    treeToGraph(root)\n    //console.log(adjList)\n    \n    while (queue.length > 0 && depth <= k) {\n        let current = queue.shift()\n        let destinations = adjList[current]\n        \n        for (let i = 0; i < destinations.length; i++) {\n            //console.log(destinations[i])\n            \n            if (depth === k) {\n                let temp = adjList[destinations[i]]\n                temp = temp.filter(f => f !== target.val)\n                \n                res.push(...temp)\n                \n                \n            }\n            \n            if (!visited.has(current)) {\n                visited.add(current)\n                queue.push(destinations[i])\n            }\n        }\n        depth++\n    }\n    \n    return res   \n}\n    \n    ","compare_result":"111100101010100000101000000000000000010010100100110101100","title_slug":"all-nodes-distance-k-in-binary-tree","has_notes":false}