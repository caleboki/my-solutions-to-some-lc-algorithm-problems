{"id":934919236,"lang":"javascript","lang_name":"JavaScript","time":"2 months, 1 week","timestamp":1681678411,"status":10,"status_display":"Accepted","runtime":"954 ms","url":"/submissions/detail/934919236/","is_pending":"Not Pending","title":"Height of Binary Tree After Subtree Removal Queries","memory":"100.1 MB","code":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number[]} queries\n * @return {number[]}\n */\n// var treeQueries = function(root, queries) {\n//     const originalRoot = root, heights = []\n\n//     const findSubtree = (tree, node) => {}\n\n//     const removeSubtree = (tree, node) => {\n//         if (!tree) return null\n//         if (!node) return tree\n\n\n\n//         return tree\n//     }\n\n//     const populateHeights = (subtree) => {}\n\n//     for (let query of queries) {\n//         const subtree = findSubtree(root, query)\n//         populateHeights(subtree)\n//         root = originalRoot\n//     }\n\n//     return heights\n// };\n\n// const treeQueries = (root, queries) => {\n//     const depths = {}, heights = {}, levels = {}, result = []\n\n//     //returns height for nodes\n//     const dfs = (node, d) => {\n//         if (!node) return -1\n//         depths[node.val] = d\n\n//         let h = Math.max(dfs(node.left, d + 1), dfs(node.right, d + 1))\n//         heights[node.val] = h\n//         return h\n//     }\n//     dfs(root, 0)\n//     console.log(depths)\n\n//     for (let [node_val, d] of Object.entries(depths)) {\n//         if (!levels[d]) levels[d] = []\n//         levels[d].push(node_val)\n//         //levels[d].sort((a, b) => b-a)\n//         levels[d].length = 2\n//     }\n\n//     for (let q of queries) {\n//         let d = depths[q]\n//         if (levels[d].length === 1) {\n//             result.push(d-1)\n//         } else if (levels[d][0])\n//     }\n//     console.log(levels)\n// }\n\nconst treeQueries = (root, queries) => {\n    let maxHeight = -Infinity\n    const heights = {}, heightsAfterNodeRemoval = {}\n    const updateHeights = (node) => {\n        let currentNodeHeight\n\n        if (!node.left && !node.right) {\n            currentNodeHeight = 0\n        } else if (!node.right) {\n            currentNodeHeight = updateHeights(node.left) + 1\n        } else if (!node.left) {\n            currentNodeHeight = updateHeights(node.right) + 1\n        }\n        else {\n            currentNodeHeight = Math.max(updateHeights(node.left), updateHeights(node.right)) + 1\n        }\n        maxHeight = Math.max(maxHeight, currentNodeHeight)\n        \n        heights[node.val] = currentNodeHeight\n        \n        return currentNodeHeight\n    }\n\n    updateHeights(root)\n    console.log(heights)\n    const updateHeightsAfterRemoval = (node, level = 0, bestAlternateHeight = -Infinity) => {\n        if (!node.left && !node.right) return\n\n        if (node.left && !node.right) {\n            bestAlternateHeight = Math.max(level, bestAlternateHeight)\n            heightsAfterNodeRemoval[node.left.val] = bestAlternateHeight\n            return updateHeightsAfterRemoval(node.left, level + 1, bestAlternateHeight)\n        }\n\n        if (!node.left && node.right) {\n            bestAlternateHeight = Math.max(level, bestAlternateHeight)\n            heightsAfterNodeRemoval[node.right.val] = bestAlternateHeight\n            return updateHeightsAfterRemoval(node.right, level + 1, bestAlternateHeight)\n        }\n\n        const rootToLeafHeightOnLeftNodePath = level + heights[node.left.val] + 1\n        const rootToLeafHeightOnRightNodePath = level + heights[node.right.val] + 1\n\n        //if (rootToLeafHeightOnLeftNodePath === rootToLeafHeightOnRightNodePath) return\n\n        if (rootToLeafHeightOnLeftNodePath > rootToLeafHeightOnRightNodePath) {\n            bestAlternateHeight = Math.max(rootToLeafHeightOnRightNodePath, bestAlternateHeight)\n            heightsAfterNodeRemoval[node.left.val] = bestAlternateHeight\n            return updateHeightsAfterRemoval(node.left, level + 1, bestAlternateHeight)\n        } else {\n            bestAlternateHeight = Math.max(rootToLeafHeightOnLeftNodePath, bestAlternateHeight)\n            heightsAfterNodeRemoval[node.right.val] = bestAlternateHeight\n            return updateHeightsAfterRemoval(node.right, level + 1, bestAlternateHeight)\n        }\n    }\n\n    updateHeightsAfterRemoval(root)\n    console.log(heightsAfterNodeRemoval)\n    return queries.map((item) => heightsAfterNodeRemoval[item] !== undefined ? heightsAfterNodeRemoval[item] : maxHeight)\n}","compare_result":"1111111111111111111111111111111111111111","title_slug":"height-of-binary-tree-after-subtree-removal-queries","has_notes":false}