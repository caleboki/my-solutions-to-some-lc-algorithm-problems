{"id":935947521,"lang":"javascript","lang_name":"JavaScript","time":"2Â months","timestamp":1681840491,"status":10,"status_display":"Accepted","runtime":"198 ms","url":"/submissions/detail/935947521/","is_pending":"Not Pending","title":"01 Matrix","memory":"52.9 MB","code":"/**\n * @param {number[][]} mat\n * @return {number[][]}\n */\n// var updateMatrix = function(mat) {\n//     if (!mat || mat.length === 0) return mat\n    \n//     let rows = mat.length, cols = mat[0].length\n//     let queue = []\n//     let visited = new Set()\n    \n//     //Put the co-ordinates of all 0s in the queue\n    \n//     for (let i = 0; i < rows; i++) {\n//         for (let j = 0; j < cols; j++) {\n//             if (mat[i][j] === 0) {\n//                 let zeroNodes = '' + i + j\n//                 queue.push(zeroNodes)\n//                 visited.add(zeroNodes)\n//             }\n//         }\n//     }\n    \n//     let directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    \n//     while (queue.length) {\n//         let length = queue.length\n//         for (let i = 0; i < length; i++) {\n//             let currentNode = queue.shift()\n//             let currentX = currentNode[0], currentY = currentNode[1]\n            \n//             for (d of directions) {\n//                 let x = +currentX + d[0]\n//                 let y = +currentY + d[1]\n                \n//                 //check boundaries\n//                 if (x < 0 || x > rows-1 || y < 0 || y > cols-1 || visited.has('' + x + y)) {\n//                    continue \n//                 }\n//                 //console.log(mat[x][y])\n//                 mat[x][y] = mat[+currentX][+currentY] + 1\n                \n//                 queue.push('' + x + y)\n//                 visited.add('' + x + y)\n                \n                \n//             }\n//         }\n        \n//     }\n    \n//     return (mat)\n// };\n\nvar updateMatrix = function(matrix) {\n    \n    // General approach is: Loop over the full matrix to find all zeroes first.\n    // Add those to a queue and start a classic BFS, writing down a number +1 \n    // of the position we find in the Q. That way, all the neigbors of the zeroes will become 1's\n    // all their neighbors 2's etc.\n    // As we're looking for the initial set of zeroes, mark the others, mark as infinity\n    // because we don't want to get confused with future 1s we want to write down.\n   \n    let rows = matrix.length, cols = matrix[0].length\n    \n    let queue = [];        \n    \n    // Find all zeroes in the matrix\n    for (let i = 0; i < rows; i++) { \n        for (let j = 0; j < cols; j++) {   \n            if (matrix[i][j] === 0) {\n                // Note the third param here, a zero to keep track of which \"level\" we're at. \n                // The zeroes are obviously at zero. \n                // Later in the bfs we will increase this for each unvisited neighbor\n                queue.push([i, j, 0]);\n            } else {\n                matrix[i][j] = Infinity;\n            }  \n        } \n    }\n    \n    // little helper array to find neighbors in a quick forEach loop.\n    let dir = [[1,0],[0,1],[-1,0],[0,-1]];\n    \n    // Start BFS. BFS is the right choice so we minimize attempted double visits\n    // BFS is like a stain that spreads, while DFS is like tendrils reaching out.\n    while (queue.length) {\n        let pos = queue.shift();\n        \n        // write value if we find it's lower than current (like those infinities)\n        if (matrix[pos[0]][pos[1]] > pos[2]) {\n            matrix[pos[0]][pos[1]] = pos[2];\n        }\n        \n        // Look at all neighbor positions. Are they on the board? Are they not yet visited?\n        // If yes to both, add to the q, with an increased \"level\" param at pos [2] \n        dir.forEach(function(d) {\n            let next = [pos[0] + d[0], pos[1] + d[1], pos[2] + 1];\n            // valid next coordinates?\n            if (next[0] > -1 && next[0] < matrix.length && next[1] > -1 && next[1] < matrix[0].length) {\n                // not yet marked?\n                if (matrix[next[0]][next[1]] === Infinity) {\n                    // add to queue, but with increased index, which we stored at pos[2]\n                    queue.push(next);\n                }\n            }\n        });\n    }\n    return matrix;\n};","compare_result":"11111111111111111111111111111111111111111111111111","title_slug":"01-matrix","has_notes":false}