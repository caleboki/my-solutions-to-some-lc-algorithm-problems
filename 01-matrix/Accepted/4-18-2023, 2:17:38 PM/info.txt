{"id":935960768,"lang":"javascript","lang_name":"JavaScript","time":"2Â months","timestamp":1681841858,"status":10,"status_display":"Accepted","runtime":"331 ms","url":"/submissions/detail/935960768/","is_pending":"Not Pending","title":"01 Matrix","memory":"55 MB","code":"/**\n * @param {number[][]} mat\n * @return {number[][]}\n */\n// var updateMatrix = function(mat) {\n//     if (!mat || mat.length === 0) return mat\n    \n//     let rows = mat.length, cols = mat[0].length\n//     let queue = []\n//     let visited = new Set()\n    \n//     //Put the co-ordinates of all 0s in the queue\n    \n//     for (let i = 0; i < rows; i++) {\n//         for (let j = 0; j < cols; j++) {\n//             if (mat[i][j] === 0) {\n//                 let zeroNodes = '' + i + j\n//                 queue.push(zeroNodes)\n//                 visited.add(zeroNodes)\n//             }\n//         }\n//     }\n    \n//     let directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    \n//     while (queue.length) {\n//         let length = queue.length\n//         for (let i = 0; i < length; i++) {\n//             let currentNode = queue.shift()\n//             let currentX = currentNode[0], currentY = currentNode[1]\n            \n//             for (d of directions) {\n//                 let x = +currentX + d[0]\n//                 let y = +currentY + d[1]\n                \n//                 //check boundaries\n//                 if (x < 0 || x > rows-1 || y < 0 || y > cols-1 || visited.has('' + x + y)) {\n//                    continue \n//                 }\n//                 //console.log(mat[x][y])\n//                 mat[x][y] = mat[+currentX][+currentY] + 1\n                \n//                 queue.push('' + x + y)\n//                 visited.add('' + x + y)\n                \n                \n//             }\n//         }\n        \n//     }\n    \n//     return (mat)\n// };\n\n// var updateMatrix = function(matrix) {\n    \n//     // General approach is: Loop over the full matrix to find all zeroes first.\n//     // Add those to a queue and start a classic BFS, writing down a number +1 \n//     // of the position we find in the Q. That way, all the neigbors of the zeroes will become 1's\n//     // all their neighbors 2's etc.\n//     // As we're looking for the initial set of zeroes, mark the others, mark as infinity\n//     // because we don't want to get confused with future 1s we want to write down.\n   \n//     let rows = matrix.length, cols = matrix[0].length\n    \n//     let queue = [];        \n    \n//     // Find all zeroes in the matrix\n//     for (let i = 0; i < rows; i++) { \n//         for (let j = 0; j < cols; j++) {   \n//             if (matrix[i][j] === 0) {\n//                 // Note the third param here, a zero to keep track of which \"level\" we're at. \n//                 // The zeroes are obviously at zero. \n//                 // Later in the bfs we will increase this for each unvisited neighbor\n//                 queue.push([i, j, 0]);\n//             } else {\n//                 matrix[i][j] = Infinity;\n//             }  \n//         } \n//     }\n    \n//     // little helper array to find neighbors in a quick forEach loop.\n//     let dir = [[1,0],[0,1],[-1,0],[0,-1]];\n    \n//     // Start BFS. BFS is the right choice so we minimize attempted double visits\n//     // BFS is like a stain that spreads, while DFS is like tendrils reaching out.\n//     while (queue.length) {\n//         let pos = queue.shift();\n        \n//         // write value if we find it's lower than current (like those infinities)\n//         if (matrix[pos[0]][pos[1]] > pos[2]) matrix[pos[0]][pos[1]] = pos[2]\n        \n//         // Look at all neighbor positions. Are they on the board? Are they not yet visited?\n//         // If yes to both, add to the q, with an increased \"level\" param at pos [2] \n//         dir.forEach(function(d) {\n//             let next = [pos[0] + d[0], pos[1] + d[1], pos[2] + 1];\n//             // valid next coordinates?\n//             if (next[0] > -1 && next[0] < matrix.length && next[1] > -1 && next[1] < matrix[0].length) {\n//                 // not yet marked?\n//                 if (matrix[next[0]][next[1]] === Infinity) {\n//                     // add to queue, but with increased index, which we stored at pos[2]\n//                     queue.push(next);\n//                 }\n//             }\n//         });\n//     }\n//     return matrix;\n// };\n\nvar updateMatrix = function(mat) {\n    const rows = mat.length;\n    const cols = mat[0].length;\n    const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n    const dist = Array.from({length: rows}, () => Array(cols).fill(Infinity));\n    const queue = [];\n    console.log(dist)\n    \n    // Initialize distance of 0 cells to 0 and add them to the queue\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            if (mat[i][j] === 0) {\n                dist[i][j] = 0;\n                queue.push([i, j]);\n            }\n        }\n    }\n    \n    while (queue.length) {\n        const [i, j] = queue.shift();\n        \n        for (const [dx, dy] of dirs) {\n            const ni = i + dx;\n            const nj = j + dy;\n            \n            // If neighbor is within bounds and distance is greater than current cell distance + 1, update distance and add to queue\n            if (ni >= 0 && ni < rows && nj >= 0 && nj < cols && dist[ni][nj] > dist[i][j] + 1) {\n                dist[ni][nj] = dist[i][j] + 1;\n                queue.push([ni, nj]);\n            }\n        }\n    }\n    \n    return dist;\n};\n","compare_result":"11111111111111111111111111111111111111111111111111","title_slug":"01-matrix","has_notes":false}