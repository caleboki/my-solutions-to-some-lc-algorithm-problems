{"id":859155013,"lang":"javascript","lang_name":"JavaScript","time":"6 months, 1 week","timestamp":1670936063,"status":10,"status_display":"Accepted","runtime":"202 ms","url":"/submissions/detail/859155013/","is_pending":"Not Pending","title":"Shortest Path to Get Food","memory":"58.9 MB","code":"/**\n * @param {character[][]} grid\n * @return {number}\n */\nconst getFood = (grid) => {\n    if (grid.length === 0) return -1\n    \n    let minDistance = 0, queue = [], visited = new Set(), rows = grid.length, cols = grid[0].length\n    let directions = [[1, 0], [0, 1], [-1, 0], [0, -1]]\n    \n    //find starting position\n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            if (grid[i][j] === '*') {\n                queue.push([i, j])\n                visited.add(`${i}|${j}`)\n                break\n            }\n        }\n    }\n    \n    //start bfs\n    \n    while (queue.length) {\n        //All cells within the size will be at the same distance from starting cell\n        let size = queue.length\n        \n        for (let i = 0; i < size; i++) {\n            let [row, col] = queue.shift()\n            if (grid[row][col] === '#') return minDistance //Food found\n            \n            for (let d of directions) {\n                let nRow = row + d[0]\n                let nCol = col + d[1]\n                \n                //Skip visited cell and out of bound cell and obstacle cell\n                if (nRow < 0 || nCol < 0 || nRow >= rows || nCol >= cols || grid[nRow][nCol] === 'X' || visited.has(`${nRow}|${nCol}`)) continue\n\n                //Add unvisited cell to the queue  \n                visited.add(`${nRow}|${nCol}`)\n                queue.push([nRow, nCol])\n            }\n        }\n        minDistance++\n    }\n    \n    return -1\n}","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"shortest-path-to-get-food","has_notes":false}