{"id":784827096,"lang":"javascript","lang_name":"JavaScript","time":"9 months, 4 weeks","timestamp":1661618793,"status":10,"status_display":"Accepted","runtime":"1312 ms","url":"/submissions/detail/784827096/","is_pending":"Not Pending","title":"Substring With Largest Variance","memory":"47.1 MB","code":"/**\n * @param {string} s\n * @return {number}\n */\n\n/**\nThe given problem asks us to compute the maximum possible variance between 2 characters in any substring of the given string. \nThis value will be the largest difference between the highest frequence element and the lowest frequency element. \nThis problem can be broken down so that we compute the maximum possible variation between any 2 characters. \nBy computing the maximum possible variation between all unique characters and then getting the maximum among those values we can compute the largest variance for String, s. \nWe can start the problem by filling a hashmap with the characters in the string and their respective counts. \nWe can then iterate through pairs of characters using a nested loop on the maps keyset. \nOnce we have our primary character and secondary character we can compute the maximum variance for those characters using Kadane's algorithm. \nAs we iterate through the characters in our string we can check whether any of those characters belong to our pair. We can update the frequencies for those characters. \nIt is also important that we track the count of our secondary character. \nThis is so we can reset our frequencies. \nFor example, if the secondary frequency outweighs the primary frequency upto that point we know that the substring upto that point has already had its max variance computed and continuing to work with that part of the string is pointless since our variance is lower than 0 for the primary character. \nIf we have more secondary characters we can simply, reset our string to start at this new index and continue to calculate new frequencies. \nTherefore we reset our primary and secondary frequencies that we might meet a better frequence later down the iteration of  our string. \nWe can keep a global variable for the nested loops which we can compare with our current max frequency between 2 characters. \nAt the end we can simply return our variance.\n**/\n\nvar largestVariance = function(s) {\n    let variance = 0, freqMap = new Map()\n    \n    for (let c of s) {\n        if (!freqMap.has(c)) freqMap.set(c, 0)\n        freqMap.set(c, freqMap.get(c)+1)\n    }\n    \n    for (let [primaryString] of freqMap) {\n        for (let [secondaryString] of freqMap) {\n            if (primaryString === secondaryString) continue\n            \n            let primaryFreq = 0, secondaryFreq = 0, secondaryCharCount = freqMap.get(secondaryString)\n            \n            for (let currentStr of s) {\n                if (currentStr === primaryString) primaryFreq++\n                if (currentStr === secondaryString) {\n                    secondaryFreq++\n                    secondaryCharCount--\n                }\n                \n                if ((primaryFreq > 0 && secondaryFreq > 0) && (primaryFreq > secondaryFreq)) {\n                    variance = Math.max(variance, (primaryFreq - secondaryFreq))\n                }\n                \n                if (primaryFreq < secondaryFreq && secondaryCharCount > 0) { //we move to a new substring\n                   primaryFreq = 0\n                   secondaryFreq = 0\n                }\n                \n            }\n        }\n    \n    }\n    \n    return variance\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"substring-with-largest-variance","has_notes":false}