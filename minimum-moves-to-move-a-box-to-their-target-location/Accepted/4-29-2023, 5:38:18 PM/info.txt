{"id":941783916,"lang":"javascript","lang_name":"JavaScript","time":"1 month, 3 weeks","timestamp":1682804298,"status":10,"status_display":"Accepted","runtime":"319 ms","url":"/submissions/detail/941783916/","is_pending":"Not Pending","title":"Minimum Moves to Move a Box to Their Target Location","memory":"50.6 MB","code":"/**\n * @param {character[][]} grid\n * @return {number}\n */\nvar minPushBox = function(grid) {\n\tconst n = grid.length\n\tconst m = grid[0].length\n\n\tconst directions = [\n\t\t[1, 0],\n\t\t[0, 1],\n\t\t[-1, 0],\n\t\t[0, -1],\n\t]\n\n\tconst person = { x: 0, y: 0 }\n\tconst box = { x: 0, y: 0 }\n\tconst exit = { x: 0, y: 0 }\n\n\tfor (let y = 0; y < n; y++) {\n\t\tfor (let x = 0; x < m; x++) {\n\t\t\tif (grid[y][x] === 'S') {\n\t\t\t\tperson.x = x\n\t\t\t\tperson.y = y\n\t\t\t} else if (grid[y][x] === 'B') {\n\t\t\t\tbox.x = x\n\t\t\t\tbox.y = y\n\t\t\t} else if (grid[y][x] === 'T') {\n\t\t\t\texit.x = x\n\t\t\t\texit.y = y\n\t\t\t}\n\t\t}\n\t}\n\n\tconst canPersonMoveToLocation = (startX, startY, endX, endY, boxX, boxY) => {\n\t\tconst visited = new Set()\n\t\tconst queue = [[startX, startY]]\n\n\t\twhile (queue.length) {\n\t\t\tconst [x, y] = queue.shift()\n \t\t\tif (x === endX && y === endY) return true\n\n\t\t\t for (const [mx, my] of directions) {\n\t\t\t\tconst nx = mx + x\n\t\t\t\tconst ny = my + y\n\t\t\t\t// To generate a unique key for a state:\n\t\t\t\tconst nkey = `${nx},${ny}`\n\t\t\t\tconst nextSpot = grid[ny]?.[nx] ?? '#'\n\n\t\t\t\tif (!visited.has(nkey) && nextSpot !== '#') {\n\t\t\t\t\tvisited.add(nkey)\n\t\t\t\t\tif (nx !== boxX || ny !== boxY) queue.push([nx, ny])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tconst visited = new Set()\n\tconst queue = [[box.x, box.y, person.x, person.y, 0]]\n\n\twhile (queue.length) {\n\t\tconst [boxX, boxY, personX, personY, pushCount] = queue.shift()\n\n\t\tif (boxX === exit.x && boxY === exit.y) return pushCount\n\n\t\tconst stateKey = `${boxX},${boxY}-${personX},${personY}`\n\t\tif (visited.has(stateKey)) continue\n\t\tvisited.add(stateKey)\n\n\t\tfor (const [moveX, moveY] of directions) {\n\t\t\tconst nextBoxX = boxX + moveX\n\t\t\tconst nextBoxY = boxY + moveY\n\t\t\tconst nextSpot = grid[nextBoxY]?.[nextBoxX] ?? '#'\n\t\t\tif (nextSpot !== '#') {\n\t\t\t\t//check if person can be positioned from the other side of the box\n\t\t\t\tconst targetX = boxX - moveX\n\t\t\t\tconst targetY = boxY - moveY\n\t\t\t\tif (canPersonMoveToLocation(personX, personY, targetX, targetY, boxX, boxY)) {\n\t\t\t\t\tqueue.push([nextBoxX, nextBoxY, targetX, targetY, pushCount + 1])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n  return -1\n};\n","compare_result":"111111111111111111111111111111","title_slug":"minimum-moves-to-move-a-box-to-their-target-location","has_notes":false}