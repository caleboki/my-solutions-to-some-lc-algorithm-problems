{"id":600001369,"lang":"javascript","lang_name":"JavaScript","time":"1 year, 6 months","timestamp":1639181716,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/600001369/","is_pending":"Not Pending","title":"Design Add and Search Words Data Structure","memory":"N/A","code":"\n// var WordDictionary = function() {\n    \n// };\n\n// /** \n//  * @param {string} word\n//  * @return {void}\n//  */\n// WordDictionary.prototype.addWord = function(word) {\n    \n// };\n\n// /** \n//  * @param {string} word\n//  * @return {boolean}\n//  */\n// WordDictionary.prototype.search = function(word) {\n    \n// };\n\n/** \n * Your WordDictionary object will be instantiated and called as such:\n * var obj = new WordDictionary()\n * obj.addWord(word)\n * var param_2 = obj.search(word)\n */\n\n// class WordDictionary {\n//     constructor() {\n//         this.trie = {}\n//     }\n    \n//     addWord(word) {\n//         let cur = this.trie\n//         for (let alpha of word) {\n//             if (!cur[alpha]) cur[alpha] = {}\n//             cur = cur[alpha]\n//         }\n//         cur.word = true\n//     }\n    \n//     search(word) {\n        \n//         const dfs = (j, root) => {\n//             let cur = root\n//             for (let i = j; i < word.length; i++) {\n//                 let c = word[i]\n//                 if (c === '.') {\n//                     //if character is '.' implies we could potentially go\n//                     //thru 26 different paths\n//                     for (let d of Object.values(cur)) {\n//                         if (dfs(i+1, d)) return true\n//                     }\n//                     return false\n\n//                 } else {\n//                     if (!cur[c]) return false\n//                     cur = cur[c]\n//                 }\n\n//             }\n            \n//             return cur.word\n//         }\n        \n//         return dfs(0, this.trie)\n        \n//     }\n// }\n\n// function Node () {\n//     // children object to store children nodes\n//     this.children = {};\n    \n//     // boolean to check if the current node represents a letter that is the ending of a word\n//     this.isWordEnding = false;\n    \n//     // note: you might also want to store this.char here for debugging purposes or for different problems.\n// }\n\nvar WordDictionary = function() {\n    // the root is a node itself.\n    this.root = new Node();\n};\n\nWordDictionary.prototype.addWord = function(word) {\n    // we will traverse the trie starting from the root node and add nodes for each letter in word.\n    let currentNode = this.root;\n    \n    for (const char of word) {\n        // if a node exists for a given letter then don't do anything.\n        // if not create a new node for that letter.\n        currentNode.children[char] = currentNode.children[char] || new Node();\n        \n        // move on to the next node.\n        currentNode = currentNode.children[char];\n    }\n    \n    // after looping, the currentNode variable will point to the node representing the last letter of word.\n    // so we mark that node as a word ending.\n    currentNode.isWordEnding = true;\n};\n\nWordDictionary.prototype.search = function(word) {\n    // helper function to call recursively\n    const searchHelper = (currentNode, i) => {\n        \n        // if we reach the i that's the length of word and currentNode is a word ending, word exists.\n        if (i === word.length) return currentNode.isWordEnding\n        \n        const char = word[i]\n        \n        // if char is a dot, that means we can match it with any letter.\n        // to do that programmatically, we go through all of the children of the current node. why?\n        // we don't know which, if any, of the children can use the dot to make the given string.\n        // so we go through all of them and check if any of them can return true.\n        if (char === '.') {\n            for (const char of Object.keys(currentNode.children)) {\n                const child = currentNode.children[char];\n                if (searchHelper(child, i + 1)) return true\n            }\n            \n            // if no child can make use of the dot to come up with the given word,\n            // then even the alternative version (e.g 'pad') \n            // of the given string (e.g 'pa.') doesn't exist in our dictionary.\n            return false\n        } \n        \n        // if char isn't a dot, it's more straightforward...\n        else {\n            // looking for a letter that should come after another and can't find it?\n            // that means the word doesn't exist in our dictionary so return false.\n            if (!(char in currentNode.children)) return false\n            \n            // go on to the next node in our dictionary and the next letter in the word\n            return searchHelper(currentNode.children[char], i + 1)\n        }\n    }\n    \n    // we call this function by starting at our root node with the index for the first letter in the string\n    return searchHelper(this.root, 0)\n};\n\nclass Node {\n    constructor() {\n        this.children = {}\n        this.isWord = false\n    }\n}\n\n// class WordDictionary {\n//     constructor() {\n//         this.root = new Node()\n//     }\n    \n//     addWord(word) {\n//         let currentNode = this.root\n        \n//         for (const char of word) {\n//             // if a node exists for a given letter then don't do anything.\n//             // if not create a new node for that letter.\n//             currentNode.children[char] = currentNode.children[char] || new Node()\n            \n//             //on to the next node\n//             currentNode = currentNode.children[char]\n            \n//             //after iteration currentNode would point to the node representing the last\n//             //letter of the word, so we mark as a word ending\n//             currentNode.isWord = true\n//         }\n//     }\n    \n//     search(word) {\n//         const searchHelper = (currentNode, i) => {\n//             //if we reach the i that's length of word and currentNode is a word ending, word                //exists.\n//             if (i === word.length) return currentNode.isWord\n            \n//             const char = word[i]\n            \n//             // if char is a dot, that means we can match it with any letter. To do that                     // programmatically, we go through all of the children of the current node. Because             // we don't know which, if any, of the children can use the dot to make the given               // string. So we go through all of them and check if any of them can return true.\n            \n//             if (char === '.') {\n//                 for (const char of Object.keys(currentNode.children)) {\n//                     const child = currentNode.children[char]\n//                     if (searchHelper(child, i + 1)) return true\n//                 }\n//                 // if no child can make use of the dot to come up with the given word,\n//                 // then even the alternative version (e.g 'pad') \n//                 // of the given string (e.g 'pa.') doesn't exist in our dictionary.\n//                 return false\n//             } \n//             // if char isn't a dot, it's more straightforward\n//             else {\n//                 // looking for a letter that should come after another and can't find it?\n//                 // that means the word doesn't exist in our dictionary so return false.\n                \n//                 if (!(char in currentNode.children)) return false\n                \n//                 // go on to the next node in our dictionary and the next letter in the word\n//                 return searchHelper(currentNode.children[char], i + 1)\n                \n//             }\n            \n//         }\n        \n//         return searchHelper(this.root, 0)\n//     }\n// }\n\n","compare_result":"1111111101111","title_slug":"design-add-and-search-words-data-structure","has_notes":false}