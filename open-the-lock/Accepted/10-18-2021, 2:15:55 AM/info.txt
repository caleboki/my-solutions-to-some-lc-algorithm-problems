{"id":573053708,"lang":"javascript","lang_name":"JavaScript","time":"1 year, 8 months","timestamp":1634537755,"status":10,"status_display":"Accepted","runtime":"325 ms","url":"/submissions/detail/573053708/","is_pending":"Not Pending","title":"Open the Lock","memory":"59.8 MB","code":"/**\n * @param {string[]} deadends\n * @param {string} target\n * @return {number}\n */\n//See: https://leetcode.com/problems/open-the-lock/discuss/870846/Javascript-BFS\nvar openLock = function(deadends, target) {\n   \n   if (target === null || target.length === 0) return  -1\n    \n    const getNextStates = (lock) => {\n        let newLocks = new Set()\n        \n        for (let i = 0; i < 4; i++) {\n            \n            lock = lock.split('')\n            let c = lock[i]\n            \n            //moving clockwise\n            lock[i] = c === '9' ? lock[i] = '0' : lock[i] = (parseInt(lock[i]) + 1).toString()\n            //moving anti-clockwise\n            lock[i] = c === '0' ? lock[i] = '9' : lock[i] = (parseInt(lock[i]) - 1).toString()\n            \n            lock = lock.join('')\n            newLocks.add(lock)\n        }\n        \n        return newLocks\n    }\n    \n    let visited = new Set(deadends)\n    \n    let queue = ['0000']\n    let level = 0\n    \n    while (queue.length) {\n        level++\n        let length = queue.length\n        \n        for (let i = 0; i < length; i++) {\n            let currentLock = queue.shift()\n            if (visited.has(currentLock)) continue\n            if (currentLock === target) return level\n            \n            for (let nextLock of getNextStates(currentLock)) {\n                if (!visited.has(nextLock)) queue.push(nextLock)\n            }\n            visited.add(currentLock)\n        }\n    }\n    \n    return -1\n}\n\nvar openLock = function (deadends, target) {\n    if (target === null || target.length === 0) return  -1\n    \n    deadends = new Set (deadends)\n    let visited = new Set(['0000'])\n    let queue = ['0000']\n    let level = 0\n    \n    const getNextStates = (lock, ans = []) => {\n        for (let i = 0; i < 4; i++) {\n            // modulus % avoids negative numbers when using +1 or -1 (could get around this    //with an if statement)\n            ans.push(lock.slice(0,i) + ((+lock[i]+1)%10) + lock.slice(i+1)) //(i+1) is the rest of the string\n            ans.push(lock.slice(0,i) + ((+lock[i]+9)%10) + lock.slice(i+1))\n        }\n        \n        return ans\n    }\n    \n    while (queue.length) {\n        \n        const next = []\n        for (let comb of queue) {\n            if (comb === target) return level\n            if (deadends.has(comb)) continue\n            \n            for (let newComb of getNextStates(comb)) {\n                if (visited.has(newComb)) continue\n                visited.add(newComb)\n                next.push(newComb)\n            }\n            \n        }\n        level++\n        queue = next\n    }\n    \n    return -1\n}","compare_result":"111111111111111111111111111111111111111111111111","title_slug":"open-the-lock","has_notes":false}