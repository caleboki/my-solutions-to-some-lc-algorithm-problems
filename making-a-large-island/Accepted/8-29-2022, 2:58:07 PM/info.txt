{"id":786557605,"lang":"javascript","lang_name":"JavaScript","time":"9 months, 3 weeks","timestamp":1661799487,"status":10,"status_display":"Accepted","runtime":"854 ms","url":"/submissions/detail/786557605/","is_pending":"Not Pending","title":"Making A Large Island","memory":"87.4 MB","code":"/**\n * @param {number[][]} grid\n * @return {number}\n */\n// var largestIsland = function(grid) {\n//     let rows = grid.length, cols = grid[0].length, visited = new Set(), ans = 0, hasZero = false\n    \n//     const dfs = (matrix, x, y, r, c, visited) => {\n//         let pos = x + ',' + y \n        \n//         if (x > 0 || x <= r || y > 0 || y <= c || grid[x][y] === 1 || !visited.has(pos)) {\n//             visited.add(pos)\n            \n//             dfs(grid, x+1, y, r, c, visited)\n//             dfs(grid, x-1, y, r, c, visited)\n//             dfs(grid, x, y+1, r, c, visited)\n//             dfs(grid, x, y-1, r, c, visited)\n//         }\n        \n//         return visited.size \n//     }\n    \n//     for (let i = 0; i < rows; i++) {\n//         for (let j = 0; j < cols; j++) {\n//             if (grid[i][j] === 0) {\n//                 hasZero = true\n//                 grid[i][j] = 1\n//                 ans = Math.max(ans, dfs(grid, i, j, rows, cols, visited))\n//                 grid[i][j] = 0\n//             }\n//         }\n//     }\n//     return hasZero ? ans : rows*rows\n    \n// };\n\n// const largestIsland = (grid) => {\n//     let maxArea = 0\n    \n//     let rows = grid.length, cols = grid[0].length, directions = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n    \n//     let islandId = -1, islandAreas = {}\n    \n// //     let dfs = (matrix, x, y) => {\n// //         if (x < 0 || x >= rows || y < 0 || y >= cols || matrix[x][y] !== 1) return 0\n        \n// //         matrix[x][y] = islandId\n// //         let area = 1\n        \n// //         area += dfs(matrix, x+1, y)\n// //         area += dfs(matrix, x-1, y)\n// //         area += dfs(matrix, x, y+1)\n// //         area += dfs(matrix, x, y-1)\n        \n// //         return area\n        \n// //     }\n    \n//     let dfs = (matrix, x, y) => {\n//         if (0 <= x && x < rows && 0 <= y && y < cols && matrix[x][y] === 1) {\n//             matrix[x][y] = islandId\n//             let area = 1\n            \n//             for (let [a, b] of directions) {\n//                 area += dfs(matrix, x+a, y+b)\n//             }\n//             return area\n            \n            \n//         } else {\n//             return 0\n//         }\n        \n       \n        \n//     }\n    \n//     for (let i = 0; i < rows; i++) {\n//         for (let j = 0; j < cols; j++) {\n//             if (grid[i][j] === 1) {\n//                 let islandArea = dfs(grid, i, j)\n//                 islandAreas[islandId] = islandArea\n//                 islandId -= 1\n//             }\n            \n//         }\n//     }\n    \n//     for (let i = 0; i < rows; i++) {\n//         for (let j = 0; j < cols; j++) {\n//             if (grid[i][j] === 0) {\n//                 let area = 1\n                \n//                 let surrounding = new Set()\n                \n//                 for (let [x, y] of directions) {\n//                     let newX = i + x\n//                     let newY = j + y\n                    \n//                     // if (newX < 0 || newX >= rows || newY < 0 || newY >= cols || grid[newX][newY] === 0) {\n//                     //     continue\n//                     // }\n                    \n//                     if (0 <= newX && newX < rows && 0 <= newY && newY < cols && grid[newX][newY] !== 0) {\n//                         surrounding.add(grid[newX][newY])\n//                     }\n                    \n//                     for (let i of surrounding) area += islandAreas[i]\n                    \n//                     maxArea = Math.max(maxArea, area)\n                    \n                    \n//                 }\n                \n//             }\n//         }\n//     }\n    \n//     return maxArea === 0 ? rows * rows : maxArea\n    \n// }\n\nconst largestIsland = function (grid) {\n\n\tconst islandSizes = {}\n\tlet maxIslandSize = 0\n\t//make an island ID to differentiate each island\n\tlet islandID = -1\n\tconst directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n\n\t//get the size of each existing island\n\tfor (let row = 0; row < grid.length; row++) {\n\t\tfor (let col = 0; col < grid[0].length; col++) {\n\t\t\tconst tile = grid[row][col]\n\t\t\t//if the current tile is untraversed land\n\t\t\tif (tile === 1) {\n\t\t\t\tconst islandSize = getIslandSize(row, col)\n\t\t\t\t//set max island size to the new maximum island size\n\t\t\t\tmaxIslandSize = Math.max(islandSize, maxIslandSize)\n\t\t\t\t//increment the islandID \n\t\t\t\tislandID--\n\t\t\t}\n\t\t}\n\t}\n\n\t//iterate through the grid and change each water tile and see if the island length created is more than the max island size\n\tfor (let row = 0; row < grid.length; row++) {\n\t\tfor (let col = 0; col < grid[0].length; col++) {\n\t\t\tconst tile = grid[row][col]\n\t\t\t//if the tile is water\n\t\t\tif (tile === 0) {\n\t\t\t\t//calculate the new size of the island\n\t\t\t\tconst newIslandSize = getNewIslandSize(row, col)\n\t\t\t\t//set max island size to the new maximum island size\n\t\t\t\tmaxIslandSize = Math.max(newIslandSize, maxIslandSize)\n\t\t\t}\n\t\t}\n\t}\n\n\t//return max island size\n\treturn maxIslandSize\n\n\tfunction getIslandSize(row, col) {\n\t\t//if the tile is not untraversed land, return\n\t\t//if (grid[row]?.[col] !== 1) return 0\n        if (grid[row] === undefined || grid[row][col] !== 1) return 0\n\t\t\n\t\t//set the tile to the new islandID\n\t\tgrid[row][col] = islandID\n\n\t\t//if island doesn't exist in the hashmap yet\n\t\tif (islandSizes[islandID] === undefined) {\n\t\t\t//add it with a value of 1\n\t\t\tislandSizes[islandID] = 1\n\t\t}\n\t\telse {\n\t\t\t//increment the island size in the hashmap\n\t\t\tislandSizes[islandID]++\n\t\t}\n\t\t//continue in the 4 cardinal directions\n\t\tdirections.forEach(([rowMod, colMod]) => getIslandSize(row + rowMod, col + colMod))\n\t\t//return the island size\n\t\treturn islandSizes[islandID]\n\t}\n\n\tfunction getNewIslandSize(row, col) {\n\t\tconst visited = new Set()\n\t\t//start island size at one since  a water tile changed to land\n\t\tlet totalArea = 1\n\t\t//look in each cardinal direction for islands\n\t\tdirections.forEach(([rowMod, colMod]) => {\n\t\t\tconst islandID = grid[row + rowMod]?.[col + colMod]\n\t\t\t//if the islandID exists and is not water and the island has not been counted yet\n\t\t\tif (islandID !== undefined && islandID !== 0 && !visited.has(islandID)) {\n\t\t\t\t//add the island size to the total\n\t\t\t\ttotalArea += islandSizes[islandID]\n\t\t\t\t//add the island to the visited island set\n\t\t\t\tvisited.add(islandID)\n\t\t\t}\n\t\t})\n\t\t//return the new island size\n\t\treturn totalArea\n\t}\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"making-a-large-island","has_notes":false}