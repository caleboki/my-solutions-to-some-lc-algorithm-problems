{"id":929749681,"lang":"javascript","lang_name":"JavaScript","time":"2 months, 2 weeks","timestamp":1680889511,"status":10,"status_display":"Accepted","runtime":"786 ms","url":"/submissions/detail/929749681/","is_pending":"Not Pending","title":"Sliding Window Maximum","memory":"76.3 MB","code":"/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\n// var maxSlidingWindow = function(nums, k) {\n//     let output = []\n    \n//     for (let i = 0; i < nums.length-k+1; i++) {\n//         let max = nums[i]\n//         for (let j = i; j < i+k; j++) {\n//             max = Math.max(max, nums[j])\n//         }\n//         output.push(max)\n//     }\n//     return output\n// };\n\n// The given problem requires finding the maximum element in every sliding window of size k in an array of integers. The initial solution uses a nested loop to traverse every window and find its maximum element, resulting in a time complexity of O(n*k), where n is the length of the input array.\n\n// To make the solution more performant, we can use a deque data structure to store the indices of the maximum elements in each window. A deque allows us to efficiently add and remove elements from both ends.\n\n// We start by initializing an empty deque and an empty result array. We then traverse the input array and do the following for each element:\n\n// Remove indices from the deque that are out of range (i.e., indices that are no longer in the current window).\n// Remove indices from the deque whose corresponding elements are smaller than the current element, as those elements are no longer candidates for being the maximum element in the current window.\n// Add the current index to the deque.\n// If the current index is greater than or equal to k-1 (i.e., we have processed at least k elements), add the maximum element in the current window to the result array, which is the first element of the deque.\n// By using a deque to store the indices of the maximum elements, we avoid the nested loop and the repeated traversal of each window to find the maximum element. This optimized solution has a time complexity of O(n), where n is the length of the input array, and a space complexity of O(k), where k is the size of the sliding window.\n\nconst maxSlidingWindow = (nums, k) => {\n  const n = nums.length;\n  const result = [];\n  const deque = [];\n\n  for (let i = 0; i < n; i++) {\n    // Remove indices that are out of range\n    while (deque.length && deque[0] < i - k + 1) {\n      deque.shift();\n    }\n\n    // Remove indices whose corresponding elements are smaller than the current element\n    while (deque.length && nums[deque[deque.length - 1]] < nums[i]) {\n      deque.pop();\n    }\n\n    // Add the current index to the deque\n    deque.push(i);\n\n    // Add the maximum element in the current window to the result array\n    if (i >= k - 1) {\n      result.push(nums[deque[0]]);\n    }\n  }\n  return result;\n};\n","compare_result":"111111111111111111111111111111111111111111111111111","title_slug":"sliding-window-maximum","has_notes":false}