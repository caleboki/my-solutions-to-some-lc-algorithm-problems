{"id":594521482,"lang":"javascript","lang_name":"JavaScript","time":"1 year, 6 months","timestamp":1638207038,"status":10,"status_display":"Accepted","runtime":"660 ms","url":"/submissions/detail/594521482/","is_pending":"Not Pending","title":"LRU Cache","memory":"93.6 MB","code":"/**\n * @param {number} capacity\n */\n// var LRUCache = function(capacity) {\n//     this.capacity = capacity;\n//     this.cache = new Map();\n// };\n\n// /** \n//  * @param {number} key\n//  * @return {number}\n//  */\n// LRUCache.prototype.get = function(key) {\n\n//    if (!this.cache.has(key)) return -1\n    \n//     //delete the key from the Map, and add it again, so that it is added at the end of the Map\n// \t// this key will be recently used, hence will be evicted last in case of cache filled      //capacity\n    \n//     let access = this.cache.get(key)\n//     this.cache.delete(key)\n//     this.cache.set(key, access)\n   \n//     return access   \n// };\n\n// /** \n//  * @param {number} key \n//  * @param {number} value\n//  * @return {void}\n//  */\n// LRUCache.prototype.put = function(key, value) {\n    \n//     //delete the key from the Map, and add it again, so that it is added at the end of the Map\n// \t// this key will be recently used, hence will be evicted last in case of cache filled      //capacity\n    \n//     if (this.cache.has(key)) {\n//         this.cache.delete(key)\n//         this.cache.set(key, value)\n//     } else {\n//        this.cache.set(key, value) \n//     }  \n  \n//     if(this.cache.size > this.capacity) this.cache.delete(this.cache.keys().next().value)\n    \n// };\n\n/** \n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n\nclass LRUCache {\n    constructor(capacity) {\n        this.capacity = capacity, this.cache = new Map()\n    }\n    \n    get(key) {\n        if (!this.cache.has(key)) return -1\n        \n    //delete the key from the Map, and add it again, so that it is added at the end of the Map\n    // this key will be recently used, hence will be evicted last in case of cache filled           //capacity\n        \n        let access = this.cache.get(key)\n        this.cache.delete(key)\n        this.cache.set(key, access)\n        \n        return access\n    }\n    \n    put(key, value) {\n        //delete the key from the Map, and add it again, so that it is added at the end of the Map\n    // this key will be recently used, hence will be evicted last in case of cache filled           //capacity\n        \n        if (this.cache.has(key)) {\n            this.cache.delete(key)\n            this.cache.set(key, value)\n        } else {\n            this.cache.set(key, value)\n        }\n        \n        if (this.cache.size > this.capacity) this.cache.delete(this.cache.keys().next().value)\n    }\n        \n    \n    \n        \n}","compare_result":"1111111111111111111111","title_slug":"lru-cache","has_notes":false}