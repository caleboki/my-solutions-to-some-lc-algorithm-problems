{"id":746425747,"lang":"javascript","lang_name":"JavaScript","time":"11 months, 2 weeks","timestamp":1657748272,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/746425747/","is_pending":"Not Pending","title":"Number of Islands","memory":"N/A","code":"/**\n * @param {character[][]} grid\n * @return {number}\n */\n// var numIslands = function(grid) {\n    \n//     const dfs = (matrix, x, y, r, c) => {\n//         //handling out of bound and base case\n//         if (x < 0 || x >= r || y < 0 || y>=c || matrix[x][y] !== '1') return \n\n//         matrix[x][y] = '2'\n\n//         dfs(matrix, x+1, y, r, c) //right\n//         dfs(matrix, x-1, y, r, c) //left\n//         dfs(matrix, x, y+1, r, c) //up\n//         dfs(matrix, x, y-1, r, c) //down\n//     }\n    \n//     let nIslands = 0\n//     let rows = grid.length\n    \n//     if(rows === 0) return 0\n    \n//     //number of matrix columns. 0 because at least 1 row would always exist\n//     let cols = grid[0].length \n    \n//     //traverse grid\n//     for (let i = 0; i < rows; i++) {\n//         for(let j = 0; j < cols; j++) {\n//             if (grid[i][j] === '1') {\n//                 dfs(grid, i, j, rows, cols)\n//                 nIslands++\n//             }\n//         }\n//     }\n//     return nIslands\n// };\n\n\n// var numIslands = function(grid) {\n    \n//     let nIslands = 0\n//     let rows = grid.length\n    \n//     if(rows === 0) return 0\n    \n//     //number of matrix columns. 0 because at least 1 row would always exist\n//     let cols = grid[0].length \n    \n//     //traverse grid\n//     for (let i = 0; i < rows; i++) {\n//         for(let j = 0; j < cols; j++) {\n//             if (grid[i][j] === '1') {\n                \n//                 let queue = [[i, j]]\n                \n//                 while (queue.length) {\n//                     let current = queue.shift()\n                    \n//                     let [row, col] = current\n                    \n//                     if (row - 1 >= 0 && grid[row-1][col] === '1') {\n//                         queue.push([row-1, col])\n//                         grid[row-1][col] = '0'\n//                     }\n                    \n//                     if (row + 1 < rows && grid[row+1][col] === '1') {\n//                         queue.push([row+1, col])\n//                         grid[row+1][col] = '0'\n//                     }\n                    \n//                     if (col - 1 >= 0 && grid[row][col-1] === '1') {\n//                         queue.push([row, col-1])\n//                         grid[row][col-1] = '0'\n//                     }\n                    \n//                     if (col + 1 < cols && grid[row][col+1] === '1') {\n//                         queue.push([row, col+1])\n//                         grid[row][col+1] = '0'\n//                     }\n//                 }\n                \n//                 nIslands++\n//             }\n//         }\n//     }\n//     return nIslands\n// };\n\nconst numIslands = (grid) => {\n    if (grid.length === 0) return 0\n    \n    let rows = grid.length, cols = grid[0].length, visited = new Set(), nIslands = 0\n    \n    const dfs = (grid, x, y, r, c, visited) => {\n        if (x < 0 || x >= r || y < 0 || y >= c || grid[x][y] !== '1') return false\n        \n        let pos = `${x}{y}a`\n        if (visited.has(pos)) return false\n        visited.add(pos)\n        \n        dfs(grid, x+1, y, r, c, visited)\n        dfs(grid, x-1, y, r, c, visited)\n        dfs(grid, x, y+1, r, c, visited)\n        dfs(grid, x, y-1, r, c, visited)\n        \n        return true\n    }\n    \n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            if (grid[i][j] === '1') {\n                if (dfs(grid, i, j, rows, cols, visited)) nIslands++\n            }\n        }\n    }\n    return nIslands\n}\n\n\n\n\n\n","compare_result":"1111111101111001001111110111001010000000000010010","title_slug":"number-of-islands","has_notes":false}