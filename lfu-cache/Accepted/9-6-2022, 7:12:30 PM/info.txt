{"id":793403198,"lang":"javascript","lang_name":"JavaScript","time":"9 months, 2 weeks","timestamp":1662505950,"status":10,"status_display":"Accepted","runtime":"895 ms","url":"/submissions/detail/793403198/","is_pending":"Not Pending","title":"LFU Cache","memory":"126.1 MB","code":"// var LFUCache = function(capacity) {\n//     this.capacity = capacity;\n//     this.cache = new Map();\n//     this.useCounter = {};\n//     this.keyTrack = [];\n// };\n\n// LFUCache.prototype.get = function(key) {\n//   if (!this.cache.has(key)) {\n//       console.log(['blank'])\n//       return -1\n//   }\n    \n//   if (this.useCounter[key] !== undefined) {\n//     this.useCounter[key]++\n//   } else {\n//     this.useCounter[key] = 1\n//   }\n  \n//   this.keyTrack.splice(this.keyTrack.indexOf(key), 1)\n//   //delete this.useCounter[key]\n    \n//   this.keyTrack.unshift(key)\n    \n//   console.log(this.useCounter)\n    \n//   return this.cache.get(key)\n   \n// };\n\n\n\n// LFUCache.prototype.put = function(key, value) {\n  \n//   if (this.useCounter[key] !== undefined) {\n//     this.useCounter[key]++\n//   } else {\n//     this.useCounter[key] = 1\n//   }\n  \n//   //add item to start of array\n//   if (!this.keyTrack.includes(key)){\n//     this.keyTrack.unshift(key)\n//   } else {\n//     this.keyTrack.splice(this.keyTrack.indexOf(key), 1)\n//     this.keyTrack.unshift(key)\n//   }\n  \n  \n//   if (this.cache.size >= this.capacity) {\n    \n//     let least = Math.min(...Object.values(this.useCounter))\n//     let leastKeys = Object.keys(this.useCounter).filter(f => this.useCounter[f] === least)\n//     leastKeys = leastKeys.map((i) => Number(i))\n    \n//     if (leastKeys.length === 1) {\n//       this.cache.delete(leastKeys[0])\n//       delete this.useCounter[leastKeys[0]]\n//       this.cache.set(key, value);\n//     } else {\n//         for (let i = this.keyTrack.length - 1; i >= 0; i--) {\n//           if (leastKeys.includes(this.keyTrack[i])) {\n//             this.cache.delete(this.keyTrack[i])\n//             this.keyTrack.splice(this.keyTrack.indexOf(this.keyTrack[i]), 1)\n//             delete this.useCounter[this.keyTrack[i]]\n            \n//             break\n//           }\n//         }\n        \n//         this.cache.set(key, value);\n//     }\n    \n    \n//   } else {\n//       this.cache.set(key, value);\n    \n//   }\n//   console.log(this.useCounter)\n    \n// };\n\n\n\n/**\n * @param {number} capacity\n */\n// var LFUCache = function(capacity) {\n//     this.dict = {}\n//     this.capacity = capacity\n//     this.freq = new Map();\n//     this.counter=1;\n    \n// };\n\n// /** \n//  * @param {number} key\n//  * @return {number}\n//  */\n// LFUCache.prototype.get = function(key) {\n//     if (this.capacity === 0) return -1\n//     if(!this.dict[key]) return -1\n    \n//     this.dict[key].count++;\n    \n//     this.freq.delete(key); //? need to investigate\n//     this.freq.set(key, ++this.counter) //? need to investigate\n    \n//     return this.dict[key].val;\n// };\n\n// /** \n//  * @param {number} key \n//  * @param {number} value\n//  * @return {void}\n//  */\n// LFUCache.prototype.put = function(key, value) {\n//     if (this.capacity === 1) this.dict = {}\n    \n//     if (this.dict[key]) {\n        \n//         this.dict[key].count++;\n//         this.dict[key].val = value;\n        \n//         this.freq.delete(key); //? need to investigate\n//     } else {\n        \n//         this.dict[key] = {\n//             count:1,\n//             val:value\n//         }\n//     }\n//     this.freq.set(key, ++this.counter); //? need to investigate\n    \n//     if(Object.keys(this.dict).length>this.capacity){\n        \n//         //? need to investigate\n//         let arr = Object.keys(this.dict).sort((a,b)=>{\n//             if(this.dict[a].count===this.dict[b].count){\n//                 return this.freq.get(parseInt(a)) - this.freq.get(parseInt(b));\n//             }\n//             return this.dict[a].count-this.dict[b].count;\n//         });\n        \n//         let deleteVal = arr[0];\n//         if(deleteVal==key && this.capacity !==1){\n//             deleteVal = arr[1];\n//         }\n//         delete this.dict[deleteVal];\n        \n//     }\n    \n// };\n\n// class LFUCache {\n//     constructor(capacity) {\n//         this.capacity = capacity\n//         this.cache = new Map()\n//         this.useCounter = new Map()\n//     }\n    \n//     get(key) {\n//         if (this.capacity === 0) return -1\n//         if (!this.cache.has(key)) return -1\n        \n//         this.useCounter.set(key, this.useCounter.get(key) + 1)\n        \n//         let access = this.cache.get(key)\n//         this.cache.delete(key)\n//         this.cache.set(key, access)\n\n//         return access\n//     }\n    \n//     put(key, value) {\n        \n//         this.useCounter.set(key, (this.useCounter.get(key) + 1) || 1)\n        \n//         if (this.cache.size === this.capacity) {\n//             let useCounter = Array.from(this.useCounter)\n//             useCounter = useCounter.sort((a, b) => a[1]-b[1])\n            \n//             if (useCounter[0][1] === useCounter[1][1]) {\n//                 this.cache.delete(this.cache.keys().next().value)\n//             } else {\n//                 this.cache.delete(useCounter[0][0]) \n//             }\n//         } \n        \n//         if (this.cache.has(key)) {\n            \n//             this.cache.delete(key)\n//             this.cache.set(key, value)\n//         } else {\n//             this.cache.set(key, value)\n//         } \n//     }\n// }\n\nclass Node {\n\tconstructor(key, value, count) {\n\t\tthis.key = key;\n\t\tthis.value = value;\n\t\tthis.next = null;\n\t\tthis.prev = null;\n\t\tthis.count = count || 1;\n\t}\n}\n\nclass DLL {\n\tconstructor() {\n\t\tthis.head = null;\n\t\tthis.tail = null;\n\t\tthis.length = 0;\n\t}\n\n\tpush(key, value, count) { // adds count\n\t\tconst node = new Node(key, value, count);\n\n\t\tif (!this.head) this.head = this.tail = node;\n\t\telse {\n\t\t\tthis.tail.next = node;\n\t\t\tnode.prev = this.tail;\n\t\t\tthis.tail = node;\n\t\t}\n\n\t\tthis.length++;\n\t\treturn node;\n\t}\n\n\tshift() {\n\t\tif (!this.head) return;\n\n\t\tconst head = this.head;\n\n\t\tif (this.length === 1) this.head = this.tail = null;\n\t\telse {\n\t\t\tthis.head = head.next;\n\t\t\tthis.head.prev = null;\n\t\t\thead.next = null;\n\t\t}\n\n\t\tthis.length--;\n\t\treturn head;\n\t}\n\n\tremove(node) {\n\t\t// handle last node\n\t\tif (!node.prev && !node.next) this.head = this.tail = null;\n\t\t// handle head\n\t\telse if (!node.prev) {\n\t\t\tthis.head = node.next;\n\t\t\tthis.head.prev = null;\n\t\t}\n\n\t\t// handle tail\n\t\telse if (!node.next) {\n\t\t\tthis.tail = node.prev;\n\t\t\tthis.tail.next = null;\n\t\t}\n\n\t\t// handle in between\n\t\telse {\n\t\t\tconst prev = node.prev;\n\t\t\tconst next = node.next;\n\n\t\t\tprev.next = next;\n\t\t\tnext.prev = prev;\n\t\t}\n\n\t\tthis.length--;\n\t}\n}\n\nclass LFUCache {\n\tconstructor(capacity) {\n\t\tthis.capacity = capacity;\n\t\tthis.size = 0;\n\t\tthis.map = {}; // key: Node\n\t\tthis.counts = {}; // count: DLL\n\t\tthis.LFU = 1;\n\t}\n\n\tincrement(node) {\n\t\tconst { count, key, value } = node;\n\t\tconst newCount = count + 1;\n\n\t\t// delete and add again with updated count\n\t\tthis.counts[count].remove(node); // delete from DLL\n\n\t\t// handle empty DLL\n\t\tif (!this.counts[count].length) {\n\t\t\tdelete this.counts[count]; // remove DLL\n\n\t\t\t// last LFU in current count removed\n\t\t\t// update LFU to new LFU count\n\t\t\tif (this.LFU === count) this.LFU = newCount;\n\t\t}\n\n\t\tif (!this.counts[newCount]) this.counts[newCount] = new DLL(); // DLL DNE, create\n\n\t\tconst LL = this.counts[newCount];\n\t\tconst newNode = LL.push(key, value, newCount); // create node with updated count and add to DLL\n\n\t\tthis.map[key] = newNode; // add node to map w/ updated count\n\t}\n\n\tget(key) {\n\t\tconst node = this.map[key];\n\n\t\tif (!node) return -1;\n\n\t\tthis.increment(node);\n\t\treturn node.value;\n\t}\n\n\tevict() {\n\t\tconst DLL = this.counts[this.LFU]; // get LFU DLL\n\t\tconst LFU = DLL.shift(); // delete from DLL\n\n\t\tdelete this.map[LFU.key]; // delete from counts\n\n\t\tif (!DLL.length) delete this.counts[this.LFU]; // delete empty DLL\n\t}\n\n\tput(key, value) {\n\t\tconst node = this.map[key];\n\n\t\tif (this.capacity === 0) return; // empty capacity\n\t\tif (!node && this.size >= this.capacity) this.evict(); // handle evict\n\n\t\tif (!node) {\n\t\t\tif (!this.counts[1]) this.counts[1] = new DLL(); // if DLL DNE, create\n\n\t\t\tconst LL = this.counts[1];\n\n\t\t\tthis.map[key] = LL.push(key, value); // delete and add to map/counts/DLL\n\n\t\t\tthis.LFU = 1; // update LFU to lowest\n\t\t\tthis.size++; // increment count of nodes\n\t\t} else {\n\t\t\tnode.value = value;\n\t\t\tthis.increment(node);\n\t\t}\n\t}\n}","compare_result":"11111111111111111111111111","title_slug":"lfu-cache","has_notes":false}