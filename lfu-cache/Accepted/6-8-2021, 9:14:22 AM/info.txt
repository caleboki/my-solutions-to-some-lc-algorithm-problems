{"id":504919813,"lang":"javascript","lang_name":"JavaScript","time":"2Â years","timestamp":1623158062,"status":10,"status_display":"Accepted","runtime":"5412 ms","url":"/submissions/detail/504919813/","is_pending":"Not Pending","title":"LFU Cache","memory":"55.6 MB","code":"// var LFUCache = function(capacity) {\n//     this.capacity = capacity;\n//     this.cache = new Map();\n//     this.useCounter = {};\n//     this.keyTrack = [];\n// };\n\n// LFUCache.prototype.get = function(key) {\n//   if (!this.cache.has(key)) {\n//       console.log(['blank'])\n//       return -1\n//   }\n    \n//   if (this.useCounter[key] !== undefined) {\n//     this.useCounter[key]++\n//   } else {\n//     this.useCounter[key] = 1\n//   }\n  \n//   this.keyTrack.splice(this.keyTrack.indexOf(key), 1)\n//   //delete this.useCounter[key]\n    \n//   this.keyTrack.unshift(key)\n    \n//   console.log(this.useCounter)\n    \n//   return this.cache.get(key)\n   \n// };\n\n\n\n// LFUCache.prototype.put = function(key, value) {\n  \n//   if (this.useCounter[key] !== undefined) {\n//     this.useCounter[key]++\n//   } else {\n//     this.useCounter[key] = 1\n//   }\n  \n//   //add item to start of array\n//   if (!this.keyTrack.includes(key)){\n//     this.keyTrack.unshift(key)\n//   } else {\n//     this.keyTrack.splice(this.keyTrack.indexOf(key), 1)\n//     this.keyTrack.unshift(key)\n//   }\n  \n  \n//   if (this.cache.size >= this.capacity) {\n    \n//     let least = Math.min(...Object.values(this.useCounter))\n//     let leastKeys = Object.keys(this.useCounter).filter(f => this.useCounter[f] === least)\n//     leastKeys = leastKeys.map((i) => Number(i))\n    \n//     if (leastKeys.length === 1) {\n//       this.cache.delete(leastKeys[0])\n//       delete this.useCounter[leastKeys[0]]\n//       this.cache.set(key, value);\n//     } else {\n//         for (let i = this.keyTrack.length - 1; i >= 0; i--) {\n//           if (leastKeys.includes(this.keyTrack[i])) {\n//             this.cache.delete(this.keyTrack[i])\n//             this.keyTrack.splice(this.keyTrack.indexOf(this.keyTrack[i]), 1)\n//             delete this.useCounter[this.keyTrack[i]]\n            \n//             break\n//           }\n//         }\n        \n//         this.cache.set(key, value);\n//     }\n    \n    \n//   } else {\n//       this.cache.set(key, value);\n    \n//   }\n//   console.log(this.useCounter)\n    \n// };\n\n\n\n/**\n * @param {number} capacity\n */\n// var LFUCache = function(capacity) {\n//     this.capacity = capacity\n//     this.freq = new Map();\n//     this.counter=1;\n    \n// };\n\n// /** \n//  * @param {number} key\n//  * @return {number}\n//  */\n// LFUCache.prototype.get = function(key) {\n//     if (this.capacity === 0) return -1\n// };\n\n// /** \n//  * @param {number} key \n//  * @param {number} value\n//  * @return {void}\n//  */\n// LFUCache.prototype.put = function(key, value) {\n// };\n\nvar LFUCache = function(capacity) {\n    this.dict = {};\n    this.n = capacity;\n    this.freq = new Map();\n    this.counter=1;\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLFUCache.prototype.get = function(key) {\n    if(this.n===0){\n        return -1;\n    }\n    if(!this.dict[key]){\n        return -1;\n    }\n    this.dict[key].count+=1;\n    this.freq.delete(key);\n    this.freq.set(key,++this.counter)\n    return this.dict[key].val;\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLFUCache.prototype.put = function(key, value) {\n    if(this.n===1){\n        delete this.dict;\n        this.dict={};\n    }\n    if(this.dict[key]){\n        this.dict[key].count+=1;\n        this.dict[key].val = value;\n        this.freq.delete(key);\n    }else{\n        this.dict[key] = {\n            count:1,\n            val:value\n        }\n    }\n    this.freq.set(key,++this.counter)\n    if(Object.keys(this.dict).length>this.n){\n        let arr = Object.keys(this.dict).sort((a,b)=>{\n            if(this.dict[a].count===this.dict[b].count){\n                return this.freq.get(parseInt(a)) - this.freq.get(parseInt(b));\n            }\n            return this.dict[a].count-this.dict[b].count;\n        });\n        let deleteVal = arr[0];\n        if(deleteVal==key && this.n!==1){\n            deleteVal = arr[1];\n        }\n        delete this.dict[deleteVal];\n    }\n};","compare_result":"11111111111111111111111","title_slug":"lfu-cache","has_notes":false}