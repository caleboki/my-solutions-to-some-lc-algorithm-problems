{"id":793285482,"lang":"javascript","lang_name":"JavaScript","time":"9 months, 2 weeks","timestamp":1662493010,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/793285482/","is_pending":"Not Pending","title":"LFU Cache","memory":"N/A","code":"// var LFUCache = function(capacity) {\n//     this.capacity = capacity;\n//     this.cache = new Map();\n//     this.useCounter = {};\n//     this.keyTrack = [];\n// };\n\n// LFUCache.prototype.get = function(key) {\n//   if (!this.cache.has(key)) {\n//       console.log(['blank'])\n//       return -1\n//   }\n    \n//   if (this.useCounter[key] !== undefined) {\n//     this.useCounter[key]++\n//   } else {\n//     this.useCounter[key] = 1\n//   }\n  \n//   this.keyTrack.splice(this.keyTrack.indexOf(key), 1)\n//   //delete this.useCounter[key]\n    \n//   this.keyTrack.unshift(key)\n    \n//   console.log(this.useCounter)\n    \n//   return this.cache.get(key)\n   \n// };\n\n\n\n// LFUCache.prototype.put = function(key, value) {\n  \n//   if (this.useCounter[key] !== undefined) {\n//     this.useCounter[key]++\n//   } else {\n//     this.useCounter[key] = 1\n//   }\n  \n//   //add item to start of array\n//   if (!this.keyTrack.includes(key)){\n//     this.keyTrack.unshift(key)\n//   } else {\n//     this.keyTrack.splice(this.keyTrack.indexOf(key), 1)\n//     this.keyTrack.unshift(key)\n//   }\n  \n  \n//   if (this.cache.size >= this.capacity) {\n    \n//     let least = Math.min(...Object.values(this.useCounter))\n//     let leastKeys = Object.keys(this.useCounter).filter(f => this.useCounter[f] === least)\n//     leastKeys = leastKeys.map((i) => Number(i))\n    \n//     if (leastKeys.length === 1) {\n//       this.cache.delete(leastKeys[0])\n//       delete this.useCounter[leastKeys[0]]\n//       this.cache.set(key, value);\n//     } else {\n//         for (let i = this.keyTrack.length - 1; i >= 0; i--) {\n//           if (leastKeys.includes(this.keyTrack[i])) {\n//             this.cache.delete(this.keyTrack[i])\n//             this.keyTrack.splice(this.keyTrack.indexOf(this.keyTrack[i]), 1)\n//             delete this.useCounter[this.keyTrack[i]]\n            \n//             break\n//           }\n//         }\n        \n//         this.cache.set(key, value);\n//     }\n    \n    \n//   } else {\n//       this.cache.set(key, value);\n    \n//   }\n//   console.log(this.useCounter)\n    \n// };\n\n\n\n/**\n * @param {number} capacity\n */\nvar LFUCache = function(capacity) {\n    this.dict = {}\n    this.capacity = capacity\n    this.freq = new Map();\n    this.counter=1;\n    \n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLFUCache.prototype.get = function(key) {\n    if (this.capacity === 0) return -1\n    if(!this.dict[key]) return -1\n    \n    this.dict[key].count++;\n    \n    this.freq.delete(key); //? need to investigate\n    this.freq.set(key, ++this.counter) //? need to investigate\n    \n    return this.dict[key].val;\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLFUCache.prototype.put = function(key, value) {\n    if (this.capacity === 1) this.dict = {}\n    \n    if (this.dict[key]) {\n        \n        this.dict[key].count++;\n        this.dict[key].val = value;\n        \n        this.freq.delete(key); //? need to investigate\n    } else {\n        \n        this.dict[key] = {\n            count:1,\n            val:value\n        }\n    }\n    this.freq.set(key, ++this.counter); //? need to investigate\n    \n    if(Object.keys(this.dict).length>this.capacity){\n        \n        //? need to investigate\n        let arr = Object.keys(this.dict).sort((a,b)=>{\n            if(this.dict[a].count===this.dict[b].count){\n                return this.freq.get(parseInt(a)) - this.freq.get(parseInt(b));\n            }\n            return this.dict[a].count-this.dict[b].count;\n        });\n        \n        let deleteVal = arr[0];\n        if(deleteVal==key && this.capacity !==1){\n            deleteVal = arr[1];\n        }\n        delete this.dict[deleteVal];\n        \n    }\n    \n};\n\n// class LFUCache {\n//     constructor(capacity) {\n//         this.capacity = capacity\n//         this.cache = new Map()\n//         this.useCounter = new Map()\n//     }\n    \n//     get(key) {\n//         if (!this.cache.has(key)) return -1\n        \n//         let access = this.cache.get(key)\n//         this.cache.delete(key)\n//         this.cache.set(key, access)\n\n//         this.useCounter.set(key, this.useCounter.get(key) + 1)\n\n//         return access\n//     }\n    \n//     put(key, value) {\n//         if (!this.cache.has(key)) return -1\n//         this.useCounter.set(key, (this.useCounter.get(key) + 1) || 1)\n        \n//         if (this.cache.size === this.capacity) {\n//             let useCounter = Array.from(this.useCounter)\n//             useCounter = useCounter.sort((a, b) => a[1]-b[1])\n            \n//             if (useCounter[0][1] === useCounter[1][1]) {\n//                 this.cache.delete(this.cache.keys().next().value)\n//             } else {\n//                 this.cache.delete(useCounter[0][0]) \n//             }\n//         } \n        \n//         if (this.cache.has(key)) {\n//             let access = this.cache.get(key)\n//             this.cache.delete(key)\n//             this.cache.set(key, access)\n//         } else {\n//             this.cache.set(key, value)\n//         } \n//     }\n// }","compare_result":"11111111111111111111111000","title_slug":"lfu-cache","has_notes":false}