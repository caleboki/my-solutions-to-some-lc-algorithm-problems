{"id":698732550,"lang":"javascript","lang_name":"JavaScript","time":"1 year, 1 month","timestamp":1652452473,"status":10,"status_display":"Accepted","runtime":"130 ms","url":"/submissions/detail/698732550/","is_pending":"Not Pending","title":"Shortest Path in Binary Matrix","memory":"49.8 MB","code":"/**\n * @param {number[][]} grid\n * @return {number}\n */\n//marking visited cells on input grid\nvar shortestPathBinaryMatrix = function(grid) {\n    const getNeighbour = (d, r, c, g) => {\n        let neighbours = []\n        for (let i = 0; i < d.length; i++) {\n            let nRow = r + d[i][0]\n            let nCol = c + d[i][1]\n            \n            if (nRow < 0 || nCol < 0 || nRow >= g.length || nCol >= g[0].length || g[nRow][nCol] !== 0) {\n                continue\n            }\n            neighbours.push([nRow, nCol])\n        }\n        return neighbours \n    }\n    \n    let directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n    \n    if (grid[0][0] !== 0 || grid[grid.length - 1][grid[0].length - 1] !== 0) return -1\n    \n    let queue = [[0, 0]]\n    grid[0][0] = 1\n    \n    while (queue.length) {\n        let cell = queue.shift()\n        let [row, col] = cell\n        let distance = grid[row][col]\n        \n        if (row === grid.length - 1 && col === grid[0].length - 1) return distance\n        \n        for (let neighbour of getNeighbour(directions, row, col, grid)) {\n            let [nRow, nCol] = neighbour\n            \n            queue.push([nRow, nCol])\n            grid[nRow][nCol] = distance + 1\n        }\n    }\n    //Target was unreachable\n    return -1\n};\n\n//recording visited cells in a set\n\n// var shortestPathBinaryMatrix = function(grid) {\n//     const getNeighbour = (d, r, c, g) => {\n//         let neighbours = []\n//         for (let i = 0; i < d.length; i++) {\n//             let nRow = r + d[i][0]\n//             let nCol = c + d[i][1]\n            \n//             if (nRow < 0 || nCol < 0 || nRow >= grid.length || nCol >= grid[0].length || grid[nRow][nCol] !== 0) {\n//                 continue\n//             }\n//             neighbours.push([nRow, nCol])\n//         }\n//         return neighbours \n//     }\n    \n//     let directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n    \n//     if (grid[0][0] !== 0 || grid[grid.length - 1][grid[0].length - 1] !== 0) return -1\n    \n//     let queue = [[0, 0, 1]], visited = new Map()\n//     visited.set('00', true)\n    \n//     while(queue.length) {\n//         let cell = queue.shift()\n//         let row = cell[0], col = cell[1], distance = cell[2]\n//         if (row === grid.length - 1 && col === grid[0].length - 1) return distance\n        \n//         for (let neighbour of getNeighbour(directions, row, col, grid)) {\n//             let nRow = neighbour[0]\n//             let nCol = neighbour[1]\n            \n//             let current = nRow.toString() + nCol.toString()\n//             if (visited.has(current)) continue\n//             visited.set(current, true)\n            \n//             queue.push([nRow, nCol, distance + 1])\n//         }\n//     }\n//     return -1\n// }\n\n// Starting a new collection for each distance\n// var shortestPathBinaryMatrix = function(grid) {\n//     const getNeighbour = (d, r, c, g) => {\n//         let neighbours = []\n//         for (let i = 0; i < d.length; i++) {\n//             let nRow = r + d[i][0]\n//             let nCol = c + d[i][1]\n            \n//             if (nRow < 0 || nCol < 0 || nRow >= grid.length || nCol >= grid[0].length || grid[nRow][nCol] !== 0) {\n//                 continue\n//             }\n//             neighbours.push([nRow, nCol])\n//         }\n//         return neighbours \n//     }\n    \n//     let directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n    \n//     if (grid[0][0] !== 0 || grid[grid.length - 1][grid[0].length - 1] !== 0) return -1\n    \n//     let currentLayer = [[0, 0]], nextLayer = [], currentDistance = 1, visited = new Map()\n//     visited.set('00', true)\n    \n//     while(currentLayer.length) {\n//         for (let cell of currentLayer) {\n//             let row = cell[0]\n//             let col = cell[1]\n//             if (row === grid.length - 1 && col === grid[0].length - 1) return currentDistance\n//             for (let neighbour of getNeighbour(directions, row, col, grid)) {\n//                 let nRow = neighbour[0]\n//                 let nCol = neighbour[1]\n                \n//                 let current = nRow.toString() + nCol.toString()\n//                 if (visited.has(current)) continue\n//                 visited.set(current, true)\n                \n//                 nextLayer.push([nRow, nCol])\n//             }\n//         }\n//         currentLayer = nextLayer\n//         nextLayer = []\n//         currentDistance++\n//     }\n//     return -1\n// }\n\n//Keeping track of how many cells at each distance are on the queue\n// var shortestPathBinaryMatrix = function(grid) {\n//     const getNeighbour = (d, r, c, g) => {\n//         let neighbours = []\n//         for (let i = 0; i < d.length; i++) {\n//             let nRow = r + d[i][0]\n//             let nCol = c + d[i][1]\n            \n//             if (nRow < 0 || nCol < 0 || nRow >= grid.length || nCol >= grid[0].length || grid[nRow][nCol] !== 0) {\n//                 continue\n//             }\n//             neighbours.push([nRow, nCol])\n//         }\n//         return neighbours \n//     }\n    \n//     let directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n    \n//     if (grid[0][0] !== 0 || grid[grid.length - 1][grid[0].length - 1] !== 0) return -1\n    \n//     let queue = [[0, 0]], visited = new Map(), currentDistance = 1\n//     visited.set('00', true)\n    \n//     while (queue.length) {\n//         let nodeAtCurrentDistance = queue.length\n//         for (let i = 0; i < nodeAtCurrentDistance; i++) {\n//             let cell = queue.shift()\n//             let row = cell[0], col = cell[1]\n//             if (row === grid.length - 1 && col === grid[0].length - 1) return currentDistance\n            \n//             for (let neighbour of getNeighbour(directions, row, col, grid)) {\n//                 let nRow = neighbour[0]\n//                 let nCol = neighbour[1]\n                \n//                 let current = nRow.toString() + nCol.toString()\n//                 if (visited.has(current)) continue\n//                 visited.set(current, true)\n//                 queue.push([nRow, nCol])\n//             }\n//         }\n//         currentDistance++\n//     }\n//     return -1\n// }","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"shortest-path-in-binary-matrix","has_notes":false}