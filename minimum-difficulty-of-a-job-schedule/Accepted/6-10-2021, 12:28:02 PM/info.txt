{"id":505990722,"lang":"javascript","lang_name":"JavaScript","time":"2Â years","timestamp":1623342482,"status":10,"status_display":"Accepted","runtime":"300 ms","url":"/submissions/detail/505990722/","is_pending":"Not Pending","title":"Minimum Difficulty of a Job Schedule","memory":"44.6 MB","code":"/**\n * @param {number[]} jobDifficulty\n * @param {number} d\n * @return {number}\n */\n\n//From: https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/discuss/490455/JavaScript-Dynamic-Programming-w-explanation\n\nvar minDifficulty = function(jobDifficulty, d) {\n    // if we don't have enough jobs for the number of days return -1;\n    if (d > jobDifficulty.length) return -1\n    \n    //Initialize the cache that will have the key of starting index\n    // and number of days\n    // the value will be the value of the max for the current job plus the\n    // minimum total of all days after\n    const cache = {}\n    \n    // Depth First Search using a bottom up approach\n    // We want to return the minimum total difficulty for each starting index\n    // corresponding to each number of days left \n    const dfs = (start, numDays) => {\n        if (numDays === d) {\n            return start === jobDifficulty.length ? 0 : Infinity\n        }\n        \n        const key = `${start}-${numDays}`\n        if (cache[key] !== undefined) return cache[key]\n        const end = jobDifficulty.length - d + numDays\n        \n        let result = Infinity\n        let max = -Infinity\n        \n        for (let i = start; i <= end; i++) {\n            max = Math.max(max, jobDifficulty[i]);\n            result = Math.min(result, max + dfs(i + 1, numDays + 1));\n        }\n        \n        // save the result in the cach and return it;\n        return cache[key] = result;\n    }\n    return dfs(0, 0)\n \n};","compare_result":"11111111111111111111111111111111","title_slug":"minimum-difficulty-of-a-job-schedule","has_notes":false}